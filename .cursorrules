# AI Signal 100 - Cursor AI Rules (프로젝트 헌법)

## 🎯 프로젝트 개요  
- projectbrief.md 참조

## 🔄 Plan/Act 모드 (필수 준수)

### 기본 모드: PLAN  
- AI는 항상 **Plan 모드**로 시작합니다.  
- Plan 모드에서는 **절대로** 코드를 생성하거나 수정하지 않습니다.  
- 사용자가 코드 변경을 요구해도 계획 승인이 우선임을 알립니다.  
- 매 응답마다 현재 모드를 `# Mode: PLAN` 또는 `# Mode: ACT`로 표시합니다.

### Plan 모드 행동 규칙  
1.  **계획 수립만 수행**: 코드 작성 없이 필요한 정보 수집 및 솔루션 설계  
2.  **상세한 계획 제공**: 변경할 파일 목록, 단계별 작업 내용, 예상 결과  
3.  **사용자 승인 대기**: 계획이 완성되면 사용자의 명시적 승인을 기다림  
4.  **메모리 뱅크 참조**: 관련 MD 파일들을 참조하여 일관성 유지

### Act 모드 전환 조건  
- 사용자가 명시적으로 **"ACT"** 또는 **"실행해"**라고 지시할 때만 전환  
- 승인된 계획을 바탕으로만 실제 코드 변경 수행  
- 작업 완료 후 자동으로 Plan 모드로 복귀

## 📚 메모리 뱅크 활용

### 필수 참조 문서  
작업 시 다음 문서들을 우선 참조하세요:  
- `projectbrief.md`: 프로젝트 개요 및 목표  
- `techContext.md`: 기술 스택 및 환경 정보  
- `systemPatterns.md`: 아키텍처 패턴 및 코딩 규칙  
- `productContext.md`: 비즈니스 로직 및 기능 동작  
- `activeContext.md`: 현재 작업 상황  
- `progress.md`: 완료된 작업 내역

### 메모리 뱅크 업데이트  
- 작업 완료 후 "update memory bank" 지시 시 관련 문서 업데이트  
- 새로운 기능 추가 시 `plan.md` 생성 후 구현  
- 중요한 변경사항은 `progress.md`에 기록

## 🛠️ 코딩 규칙

### 일반 원칙  
- **언어별 컨벤션 준수**: `techContext.md`에 명시된 언어의 표준 코딩 컨벤션(예: Python의 PEP 8, JavaScript의 ESLint 규칙)을 따릅니다.  
- **타입 활용**: 정적 타이핑을 지원하는 언어(TypeScript, Python 타입 힌트 등)의 경우, `any`나 `Object` 같은 범용 타입 사용을 지양하고 명확한 타입을 정의합니다.

### 코드 구조 가이드  
- **응집도 높은 모듈**: 관련된 기능은 하나의 파일 또는 모듈로 묶어 관리합니다.  
- **관심사 분리**: 비즈니스 로직, 데이터 접근, UI 렌더링 등 각 계층의 역할을 명확히 분리합니다.  
- **일반적인 구조 예시**:

# 파일 상단: 모듈 설명 주석

# 1. 의존성 임포트 (표준 라이브러리, 서드파티, 내부 모듈 순)

import os  
from flask import Flask  
from . import utils

# 2. 상수 정의

DEFAULT_PORT = 8080

# 3. 클래스 또는 함수 정의

class MyService:  
    def __init__(self):  
        # 초기화 로직  
        pass

    def do_something(self, data):  
        # 핵심 로직  
        pass

# 4. 메인 실행 블록 (스크립트로 실행될 경우)

if __name__ == "__main__":  
    service = MyService()  
    service.do_something("test")

### 에러 처리  
- 모든 외부 연동(API 호출, DB 접근, 파일 I/O)에는 예외 처리(try-catch, try-except 등)를 적용합니다.  
- 사용자에게는 이해하기 쉬운 에러 메시지를, 로그에는 디버깅에 용이한 상세 정보를 기록합니다.

### 스타일링 (프론트엔드 프로젝트)  
- `techContext.md`에 명시된 CSS 방법론(예: Tailwind CSS, CSS-in-JS)을 따릅니다.  
- 재사용 가능한 UI 컴포넌트를 우선적으로 활용합니다.  
- 반응형 디자인을 고려하여 모바일 환경을 우선적으로 지원합니다.

## 🔒 보안 규칙

### 환경 변수  
- API 키, 데이터베이스 자격 증명 등 민감한 정보는 소스 코드에 하드코딩하지 않고 환경 변수를 사용합니다.  
- 클라이언트 사이드(웹 브라우저 등)에 민감한 정보가 담긴 환경 변수가 노출되지 않도록 각별히 주의합니다.

### 데이터 검증  
- 외부로부터 들어오는 모든 데이터(사용자 입력, API 응답 등)는 신뢰하지 않고 항상 유효성을 검증합니다.  
- 데이터베이스 쿼리 시 SQL 인젝션 등의 공격에 대비하여 ORM이나 파라미터 바인딩을 사용합니다.

## 📊 성능 최적화

### 일반/백엔드  
- **알고리즘 효율성**: 불필요한 반복이나 비효율적인 자료 구조 사용을 피합니다.  
- **데이터베이스 최적화**: N+1 쿼리 문제를 방지하고, 필요한 컬럼만 조회하며, 적절한 인덱스를 사용합니다.  
- **캐싱**: 자주 요청되지만 변경 빈도가 낮은 데이터는 캐싱 전략(예: Redis, 메모리 캐시)을 적용합니다.  
- **비동기 처리**: 오래 걸리는 작업(예: 이메일 발송, 파일 처리)은 비동기적으로 처리하여 응답 시간을 단축합니다.

### 프론트엔드  
- **렌더링 최적화**: 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG) 등을 적절히 활용하고 불필요한 리렌더링을 방지합니다.  
- **리소스 최적화**: 이미지, 스크립트 등 에셋의 크기를 최소화하고, 지연 로딩(Lazy Loading)을 적용합니다.

## 🧪 테스트 및 품질

### 코드 품질  
- Linter와 Formatter를 통해 일관된 코드 스타일을 유지합니다.  
- 변수, 함수, 클래스 이름은 그 역할이 명확히 드러나도록 의미 있게 작성합니다.  
- 복잡한 비즈니스 로직이나 알고리즘에는 이해를 돕는 주석을 추가합니다.

### 테스트  
- 핵심 비즈니스 로직에 대해서는 단위 테스트를 작성하여 안정성을 확보합니다.  
- 여러 모듈이 함께 동작하는 주요 기능은 통합 테스트를 통해 검증합니다.

## 🔄 워크플로우

### 새로운 기능 개발  
1.  **Plan**: `plan.md` 생성 및 상세 계획 수립  
2.  **Review**: 사용자가 계획 검토 및 승인  
3.  **Act**: 승인된 계획에 따라 구현  
4.  **Update**: 메모리 뱅크 업데이트

### 버그 수정  
1.  **Plan**: 문제 분석 및 해결 방안 수립  
2.  **Review**: 해결 방안 검토  
3.  **Act**: 수정 사항 구현  
4.  **Test**: 수정 사항 검증

## 📝 문서화

### 필수 문서  
- 모든 새로운 기능에 대한 `plan.md` 생성  
- 중요한 변경사항은 `progress.md`에 기록  
- 복잡한 로직은 주석으로 설명

### 메모리 뱅크 유지  
- 정기적인 문서 업데이트  
- 프로젝트 상태 반영  
- 팀원과의 지식 공유

---

**중요**: 이 규칙들은 AI의 행동을 제어하고 프로젝트의 일관성을 유지하기 위한 것입니다. 모든 작업은 Plan/Act 모드를 준수하며, 메모리 뱅크를 적극 활용하여 컨텍스트를 유지하세요.
